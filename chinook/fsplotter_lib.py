# -*- coding: utf-8 -*-
"""
Created on Mon Jan 10 11:31:20 2022

@author: Andrew
"""
import numpy as np

# import other chinook files to help create correct data structures
import chinook.klib as klib
import chinook.TB_lib as TBlib


# setting up fundamental constants
uBohr = 5.29e-11
uAngs = 1e-10


def create_kobject(case):
    '''
    Function to create kobjects using the klib library.
    '''
    kpoints,kpoints_linear = get_kpoints_from_spaghettiene(case)
    labels,kpoints_brk_line = get_labels_from_klist(case)
    
    kobj = klib.kpath(kpoints)#need to pass in points
    
    # updates the kobject now that we've instantiated it with our points
    kobj.kcut = kpoints_linear
    kobj.kcut_brk = kpoints_linear[kpoints_brk_line]
    kobj.labels = labels
    
    return kobj
    
    
    


def get_kpoints_from_spaghettiene(case):
    '''
    Function to extract kpoints from case.spaghetti_ene file. Does this by
    going through the file until it reaches the second band, whilst extracting
    the kvalues
    '''
    
    kpoints = []
    kpoints_linear = []
    
    print('get_kpoints_from_spaghettiene: Opening ' + case + '.spaghetti_ene')
    
    f = open(case + '.spaghetti_ene','r')
    
    nband = 0
    for line in f: # will go through the first set of lines initially, getting the k values
        if 'bandindex' in line:
            nband += 1
            if nband > 1: # if we've been through the first band entirely, break from the loop
                break
        else:
            vals = [v for v in line.split(' ') if v] # splits line, removes whitespace
            kx = float(vals[0])
            ky = float(vals[1])
            kz = float(vals[2])
            
            kpoints.append([kx,ky,kz]) # are already given in absolute units!
            kpoints_linear.append(float(vals[3]))
    
    f.close()
    print('get_kpoints_from_spaghettiene: Closing {}.spaghetti_ene'.format(case))

    # formats the arrays into numpy arrays
    kpoints = np.array(kpoints)
    kpoints_linear = np.array(kpoints_linear)

    return kpoints,kpoints_linear




def get_bands_from_spaghettiene(case):
    '''
    Function to extract bands from case.spaghetti_ene file and return them in
    the appropriate unmpy array format
    '''
    
    bands = []
    numbands = 0

    print('get_bands_from_spaghettiene: Opening {}.spaghetti_ene'.format(case))
    f = open('{}.spaghetti_ene'.format(case),'r') # opens the file for reading
    
    bandE = []
    for line in f: # loops through all the lines in the file
    
        if 'bandindex' in line or not line: # implies we've reached a new band, or end of file
            numbands += 1
            # need to append current band data onto the bands data structure
            if bandE != []: # as long as the current band isn't empty (i.e. upon initialisation)
                bands.append(bandE)
                bandE = []
                
        else: # if the line simply has numbers, etc
            energies = [e for e in line.split(' ') if e] # removes all empty strings from list, incase line has weird spacings
            bandE.append(float(energies[4])) # returning the float strips the trailing \n
            
    f.close() # closes the spaghettiene file to avoid file corruption
    print('get_bands_from_spaghettiene: Closing {}.spaghetti_ene'.format(case))
    
    # we add 1 to the number of bands at the end of the file, so we subtract it here
    numbands = numbands - 1
    
    # converts bands, kpoints, to numpy arrays
    bands = np.transpose(np.array(bands))
    
    return bands,numbands




def get_labels_from_klist(case):
    '''
    Function to get the labels and cut points from the case.klist_band file.
    Returns the text labels and the linenumbers of the breaks (changes in direction)
    '''
    
    labels = []
    kpoints_brk_line = []
    numline = -1
    
    print('get_labels_from_klist: Opening {}.klist_band'.format(case))
    f = open('{}.klist_band'.format(case),'r')
    
    for line in f:
        numline += 1
        if line[0] != ' ': #if the line starts with characters, indicating a special point
            line = [e for e in line.split(' ') if e] # splits the line and removes whitespace
            if 'END' not in line[0]:
                labels.append(line[0])
                kpoints_brk_line.append(numline)
    
    f.close()
    print('get_labels_from_klist: Closing {}.klist_band'.format(case))

    # adjust labels so they display like Latex labels
    for i,lab in enumerate(labels):
        if lab == 'GAMMA': # include any other special points
            lab = '\\Gamma'
        labels[i] = '${}$'.format(lab)
    
    return labels,kpoints_brk_line



def change_kobject_TB(case,kobj,TB):
    '''
    A function to change a TB object and a kobject to allow us to load in our 
    own data generated by WIEN2K. 
    '''
    # uses the above functions to load in the kpoints, labels, etc
    kpoints,kpoints_linear = get_kpoints_from_spaghettiene(case)
    labels,kpoints_brk_line = get_labels_from_klist(case)
    
    
    # updates the kobject
    kobj.kpts = kpoints
    kobj.kcut = kpoints_linear
    kobj.kcut_brk = kpoints_linear[kpoints_brk_line]
    kobj.labels = labels
    
    TB.Kobj = kobj
    
    # uses the functions above to load in the bands and put them into the TB object
    bands,numbands = get_bands_from_spaghettiene(case)
    TB.Eband = bands  
    # need to change the TB.basis object to have a length of numbands
    #print(TB.basis)
    TB.basis = [ii for ii in range(numbands)]
    
    return kobj,TB
        
    
def get_PLV_from_struct(case):
    '''
    A function to extract the PLVs from the case.struct file.
    The function assumes the PLVs are given on the 4th line of the file.
    '''
    # load in the struct file
    f = open('{}.struct'.format(case),'r')
    fcont = f.read().split('\n') # load the files contents as lines into fcont
    f.close()
    print('get_PLV_from_struct: Data loaded from {}.struct'.format(case))
    
    # the third line contains info on the mode of calculation: relative or absolute coords, and lattice vectors in bohr or angstrom
    line = fcont[2]
    if 'MODE OF CALC' in line: # just checking correct line
        elem = [s for s in line.split(' ') if s] # split line and remove whitespace
        # calc_mode not needed if we're just extracting the PLVS
        #calc_mode = elem[2].split('=')[1] # gets the calc mode, RELA or (ABS?)
        unit = elem[3].split('=')[1] # gets the unit type, bohr or (ang?)
    else: print('get_PLV_from_struct: {}.struct format is unrecognised'.format(case))
    
    # the fourth line gives the a,b,c,alpha,beta,gamma values
    # we can use these to obtain the lattice vectors
    line = fcont[3]
    elem = [s for s in line.split(' ') if s] # split line and remove whitespace
    a = float(elem[0])
    b = float(elem[1])
    c = float(elem[2])
    # angles are converted to radians
    degToRad = np.pi / 180
    alpha = float(elem[3]) * degToRad
    beta = float(elem[4]) * degToRad
    gamma = float(elem[5]) * degToRad
    
    # all values are rounded to 8 deimal places, before being premultiplied by their magnitude
    vec_a = a * np.array([1,0,0])
    vec_b = b * np.array([np.round(np.cos(gamma),decimals=8),np.round(np.sin(gamma),decimals=8),0])
    
    l = np.round(np.cos(beta) , decimals=8)
    m = np.round(( np.cos(alpha) - (np.cos(gamma) * np.cos(beta)) ) / ( np.sin(gamma) ),decimals = 8)
    n = np.round(np.sqrt( 1 - l**2 - m**2 ),decimals=8)
    vec_c = c* np.array([l,m,n])
    
    avec = np.array([vec_a,vec_b,vec_c])
    # need to perform unit change from bohr to angstrom in this.
    if unit == 'bohr':
        avec = avec / uBohr
    avec = avec * uAngs
    
    return avec
    
def get_z_from_file():
    '''
    Function to load in the atomic_mass.txt file and put its contents into a dictionary
    '''
    f = open('chinook/atomic_mass.txt','r')
    fcont = [line for line in f.read().split('\n') if line]
    f.close()
    Zdict = {}
    for line in fcont:
        elem = [e for e in line.split() if e]
        Zdict[elem[1]] = int(elem[0])
    return Zdict
    

    
def get_atoms_from_struct(case,avec):
    '''
    Function for extracting the numebr of atoms in the basis and their positions,
    using the case.struct file.
    This will then be used to set up the dictionary for use in the basis object
    '''
    
    # need to open the file and extract its contents
    f = open('{}.struct'.format(case),'r')
    fcont = f.read().split('\n') # split the file into lines
    f.close()
    print('get_atoms_from_struct: Extracted data from {}.struct'.format(case))
    
    line = fcont[2] # extract the third line, to determine the calculation type for the atomic positions
    if 'MODE OF CALC' in line:
        # If we have the correct line, we take the mode of calculation, rela or abs
        calc_mode = [e for e in line.split(' ') if e][2].split('=')[1].lower()
    
    Zdict = get_z_from_file()
    
    atoms = []
    Z = {}
    pos = []
    fcont = fcont[4:]  # take the 5th line onwards, as first four are setup
    for i,line in enumerate(fcont):
        if 'ATOM' in line: # if the word atom is in the line, we've found a non-equivelent atom
            j = 0
            line = line[4:] # takes off the characters 'ATOM' from the line
            while 'LOCAL ROT MATRIX' not in line: # keeps going for all the atoms of one type
                elem = [e for e in line.split(' ') if e] # splits the line by spacing and removes whitespaces
                atom_index = elem[0][1:-1] # removes the minus sign from the front and trailing colon
                
                print(elem)
                
                # need to extract the X, Y and Z values: (rounded to 8 dp)
                # these values are relative to the lattice vectors
                x = np.round(float(elem[1].split('=')[1]),decimals=8)
                y = np.round(float(elem[2].split('=')[1]),decimals=8)
                z = np.round(float(elem[3].split('=')[1]),decimals=8)
    
                # NEED TO LOOK INTO WHAT TO DO IF NOT RELATIVE!!!!
                if calc_mode == 'rela':
                    atom_pos = x*avec[0] + y*avec[1] + z*avec[2]
                else:
                    print('get_atoms_from_struct: calc_mode not RELA, send help!')
                    return
                
                atoms.append(atom_index)
                pos.append(atom_pos)
                
                j = j+ 2
                line = fcont[i+j]
            # once the line with 'LOCAL ROT MATRIX' has been reached, need to go back one line and extract atom type
            line = fcont[i+j-1]
            elem = [e for e in line.split(' ') if e]
            
            atom_type = elem[0] # extracts the string for the atom type
            Z[atom_index] = Zdict[atom_type] # get_Z is placeholder for getting Z from atom string.
            
            i = i+j
            
               
                
            
    
    
    