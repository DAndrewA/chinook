# -*- coding: utf-8 -*-
"""
Created on Mon Jan 10 11:31:20 2022

@author: Andrew
"""
import numpy as np

# import other chinook files to help create correct data structures
import chinook.klib as klib
import chinook.TB_lib as TBlib


# setting up fundamental constants
uBohr = 5.29e-11
uAngs = 1e-10


def create_kobject(case):
    '''
    Function to create kobjects using the klib library.
    '''
    kpoints,kpoints_linear = get_kpoints_from_spaghettiene(case)
    labels,kpoints_brk_line = get_labels_from_klist(case)
    
    kobj = klib.kpath(kpoints)#need to pass in points
    
    # updates the kobject now that we've instantiated it with our points
    kobj.kcut = kpoints_linear
    kobj.kcut_brk = kpoints_linear[kpoints_brk_line]
    kobj.labels = labels
    
    return kobj
    
    
    


def get_kpoints_from_spaghettiene(case):
    '''
    Function to extract kpoints from case.spaghetti_ene file. Does this by
    going through the file until it reaches the second band, whilst extracting
    the kvalues
    '''
    
    kpoints = []
    kpoints_linear = []
    
    print('get_kpoints_from_spaghettiene: Opening ' + case + '.spaghetti_ene')
    
    f = open(case + '.spaghetti_ene','r')
    
    nband = 0
    for line in f: # will go through the first set of lines initially, getting the k values
        if 'bandindex' in line:
            nband += 1
            if nband > 1: # if we've been through the first band entirely, break from the loop
                break
        else:
            vals = [v for v in line.split(' ') if v] # splits line, removes whitespace
            kx = float(vals[0])
            ky = float(vals[1])
            kz = float(vals[2])
            
            kpoints.append([kx,ky,kz]) # are already given in absolute units!
            kpoints_linear.append(float(vals[3]))
    
    f.close()
    print('get_kpoints_from_spaghettiene: Closing {}.spaghetti_ene'.format(case))

    # formats the arrays into numpy arrays
    kpoints = np.array(kpoints)
    kpoints_linear = np.array(kpoints_linear)

    return kpoints,kpoints_linear




def get_bands_from_spaghettiene(case):
    '''
    Function to extract bands from case.spaghetti_ene file and return them in
    the appropriate unmpy array format
    '''
    
    bands = []
    numbands = 0

    print('get_bands_from_spaghettiene: Opening {}.spaghetti_ene'.format(case))
    f = open('{}.spaghetti_ene'.format(case),'r') # opens the file for reading
    
    bandE = []
    for line in f: # loops through all the lines in the file
    
        if 'bandindex' in line or not line: # implies we've reached a new band, or end of file
            numbands += 1
            # need to append current band data onto the bands data structure
            if bandE != []: # as long as the current band isn't empty (i.e. upon initialisation)
                bands.append(bandE)
                bandE = []
                
        else: # if the line simply has numbers, etc
            energies = [e for e in line.split(' ') if e] # removes all empty strings from list, incase line has weird spacings
            bandE.append(float(energies[4])) # returning the float strips the trailing \n
            
    f.close() # closes the spaghettiene file to avoid file corruption
    print('get_bands_from_spaghettiene: Closing {}.spaghetti_ene'.format(case))
    
    # we add 1 to the number of bands at the end of the file, so we subtract it here
    numbands = numbands - 1
    
    # converts bands, kpoints, to numpy arrays
    bands = np.transpose(np.array(bands))
    
    return bands,numbands




def get_labels_from_klist(case):
    '''
    Function to get the labels and cut points from the case.klist_band file.
    Returns the text labels and the linenumbers of the breaks (changes in direction)
    '''
    
    labels = []
    kpoints_brk_line = []
    numline = -1
    
    print('get_labels_from_klist: Opening {}.klist_band'.format(case))
    f = open('{}.klist_band'.format(case),'r')
    
    for line in f:
        numline += 1
        if line[0] != ' ': #if the line starts with characters, indicating a special point
            line = [e for e in line.split(' ') if e] # splits the line and removes whitespace
            if 'END' not in line[0]:
                labels.append(line[0])
                kpoints_brk_line.append(numline)
    
    f.close()
    print('get_labels_from_klist: Closing {}.klist_band'.format(case))

    # adjust labels so they display like Latex labels
    for i,lab in enumerate(labels):
        if lab == 'GAMMA': # include any other special points
            lab = '\\Gamma'
        labels[i] = '${}$'.format(lab)
    
    return labels,kpoints_brk_line



def change_kobject_TB(case,kobj,TB):
    '''
    A function to change a TB object and a kobject to allow us to load in our 
    own data generated by WIEN2K. 
    '''
    # uses the above functions to load in the kpoints, labels, etc
    kpoints,kpoints_linear = get_kpoints_from_spaghettiene(case)
    labels,kpoints_brk_line = get_labels_from_klist(case)
    
    
    # updates the kobject
    kobj.kpts = kpoints
    kobj.kcut = kpoints_linear
    kobj.kcut_brk = kpoints_linear[kpoints_brk_line]
    kobj.labels = labels
    
    TB.Kobj = kobj
    
    # uses the functions above to load in the bands and put them into the TB object
    bands,numbands = get_bands_from_spaghettiene(case)
    TB.Eband = bands  
    # need to change the TB.basis object to have a length of numbands
    #print(TB.basis)
    TB.basis = [ii for ii in range(numbands)]
    
    return kobj,TB
    
    
def create_basisObject(case):
    '''
    Function to create the Chinook basis object from a case.struct file
    
    
    Things to do:
        Extract the primitive lattice vectors
        
        Extract the information for each individual atom and get it into a format thats usable
        
        Get a system to convert atom type into Z, using that text file
        
        Make sure atom's are repeated properly within the BZ (space group, symmetry operations, etc.)
        
        
    '''
    # load in the text file
    f = open('{}.struct'.format(case),'r')
    #------ NOTE: This will initially work with primitive lattices
    fcont = f.read().split('\n') # load the files contents as lines into fcont
    f.close()
    print('create_basisObject: Data loaded from {}.struct'.format(case))
    
    #take the first line of the file and use it as the label for the system
    label = str([s for s in fcont[0].split(' ') if s])
    
    # lattice type appears to be the last element of the second line
    lattice_type = [s for s in fcont[1].split(' ') if s][-1]
    
    
    
def get_PLV_from_struct(case):
    '''
    A function to extract the PLVs from the case.struct file.
    The function assumes the PLVs are given on the 4th line of the file.
    '''
    # load in the struct file
    f = open('{}.struct'.format(case),'r')
    fcont = f.read().split('\n') # load the files contents as lines into fcont
    f.close()
    print('get_PLV_from_struct: Data loaded from {}.struct'.format(case))
    
    # the third line contains info on the mode of calculation: relative or absolute coords, and lattice vectors in bohr or angstrom
    line = fcont[2]
    if 'MODE OF CALC' in line: # just checking correct line
        elem = [s for s in line.split(' ') if s] # split line and remove whitespace
        # calc_mode not needed if we're just extracting the PLVS
        #calc_mode = elem[2].split('=')[1] # gets the calc mode, RELA or (ABS?)
        unit = elem[3].split('=')[1] # gets the unit type, bohr or (ang?)
    else: print('get_PLV_from_struct: {}.struct format is unrecognised'.format(case))
    
    # the fourth line gives the a,b,c,alpha,beta,gamma values
    # we can use these to obtain the lattice vectors
    line = fcont[3]
    elem = [s for s in line.split(' ') if s] # split line and remove whitespace
    a = float(elem[0])
    b = float(elem[1])
    c = float(elem[2])
    # angles are converted to radians
    degToRad = np.pi / 180
    alpha = float(elem[3]) * degToRad
    beta = float(elem[4]) * degToRad
    gamma = float(elem[5]) * degToRad
    
    # all values are rounded to 8 deimal places, before being premultiplied by their magnitude
    vec_a = a * np.array([1,0,0])
    vec_b = b * np.array([np.round(np.cos(gamma),decimals=8),np.round(np.sin(gamma),decimals=8),0])
    
    l = np.round(np.cos(beta) , decimals=8)
    m = np.round(( np.cos(alpha) - (np.cos(gamma) * np.cos(beta)) ) / ( np.sin(gamma) ),decimals = 8)
    n = np.round(np.sqrt( 1 - l**2 - m**2 ),decimals=8)
    vec_c = c* np.array([l,m,n])
    
    avec = np.array([vec_a,vec_b,vec_c])
    # need to perform unit change from bohr to angstrom in this.
    if unit == 'bohr':
        avec = avec / uBohr
    avec = avec * uAngs
    
    return avec
    
    
    
    
    
    
    